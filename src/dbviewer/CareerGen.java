/* Copyright (C) 2014 Mark Ferguson This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. */package dbviewer;import java.util.ArrayList;import javax.swing.JLabel;import panels.Panel4Careers;import panels.Panel4LabelComboButton;/** @author maggot.iiss */public class CareerGen {  //<editor-fold defaultstate="collapsed" desc="variables">  private static String string = null;  /**   selected career   */  public static final String career = "Army";  /**   obtained rank   */  public static int rank = 0;  /**   number of tems served   */  public static int terms = 0;  /**   Officer material   */  public static boolean commissioned = false;  private static boolean muster = false;  /**   var   */  public static int i = 0;  /**   var   */  public static int j = 0;  /**   var   */  public static int k = 0;  private static int num = 0;  private static int dms[];  private static String failure = "";  private static String success = "";  private static int target = 0;  private static int roll = 0;  /**   arraylist   */  public static ArrayList<String> al = new ArrayList<>();  /**   material posessions   */  public static ArrayList<String> mat = new ArrayList<>();  /**   modifier   */  public static ArrayList<String> mod = new ArrayList<>();  /**   from muster   */  public static ArrayList<String> cash = new ArrayList<>();  /**   skills gained   */  public static ArrayList<String> skill = new ArrayList<>();  private static int mats = 0;  private static int mods = 0;  /**   cash from muster   */  public static int cashs = 0;  private static int skills = 0;  /**   case from muster   */  public static int KCr = 0;  /**   skill names gained?   */  public static ArrayList<String> names = new ArrayList<>();  /**   benefits received   */  public static ArrayList<String> benefits = new ArrayList<>();  /**   skill or benefits returned   */  public static ArrayList<String> returns = new ArrayList<>();  //</editor-fold>  /**   general test entry point   */  public static void start() {  }  /**   @return name of class   */  @Override  public String toString() {    return "" + getClass().getName() + "[career = " + career + "]";  }  /**   @param comp component number of combobox   @return string from selected combo   */  public static String getSelectedItem(int comp) {    string = Panel4Careers.p4lcb.getSelectedItemFromCombo(comp).toString();    return "" + string;  }  /**   @param comps array of component locations   @return total DMs for addition to die roll   */  public static String getDMs(int[] comps) {    num = 0;    for (i = 0; i < comps.length; i++) {      num += Integer.parseInt(checkScores(Panel4Careers.p4lcb        .getSelectedItemFromCombo(comps[i]).toString(), comps[i]));    }    return "" + num;  }  /**   @return target number to roll against   */  public static String getEnlist() {    string = getSelectedItem(1);    return string;  }  /**   @param stage "Enlist","Survival","Commission","Promotion","Reenlist"   @return integer array of combobox locations containing required number   */  public static int[] getDMs(String stage) {    switch (stage) {      case "Enlist":        dms = new int[]{4, 7};        break;      case "Survival":        dms = new int[]{16};        break;      case "Commission":        dms = new int[]{22};        break;      case "Promotion":        dms = new int[]{28};        break;      case "Reenlist":        dms = new int[]{};        break;    }    Debug.debug("getDMs(dms) = " + getDMs(dms));    return dms;  }  /**   @return target number to roll against   */  public static String getSurvival() {    string = getSelectedItem(13);    return string;  }  /**   @return target number to roll against   */  public static String getCommission() {    string = getSelectedItem(19);    return string;  }  /**   @return target number to roll against   */  public static String getPromotion() {    string = getSelectedItem(25);    return string;  }  /**   @return target number to roll against   */  public static String getReenlist() {    string = getSelectedItem(31);    muster = true;    return string;  }  /**   @param num   number of dice to roll   @param sides number of sides on dice   @return total of dice   */  public static int rollDice(int num, int sides) {    int total = 0;    for (i = 0; i < num; i++) {      total += Math.random() * sides + 1;    }//    Debug.debug("rollDice = " + total);    return total;  }  /**   @param attr target string ie "DEX 5"   @param comp component location   @return string pass or fail, compared to attribute   */  public static String checkScores(String attr, int comp) {    string = null;    String att = attr.substring(0, 3);    String numa = attr.substring(4, attr.length());    int x = 0;    switch (numa) {      case "A":        x = 10;        break;      case "B":        x = 11;        break;      case "C":        x = 12;        break;      case "D":        x = 13;        break;      case "E":        x = 14;        break;      case "F":        x = 15;        break;      default:        try {          x = Integer.parseInt(numa);        } catch (NumberFormatException nfe) {        }        break;    }    int idx = 0;    Debug.debug("numa = " + numa);    switch (att) {      case "STR":        idx = 0;        break;      case "DEX":        idx = 1;        break;      case "END":        idx = 2;        break;      case "INT":        idx = 3;        break;      case "EDU":        idx = 4;        break;      case "SOC":        idx = 5;        break;    }    int stat = UXP.hex2Num(idx, Panel4Careers.getUPP());    int req = x;    if (stat >= req) {      string = "Pass - " + Panel4Careers.p4lcb.getSelectedItemFromCombo(comp)        .toString()        + " <= " + att + UXP.hex2Num(idx, Panel4Careers.getUPP());      JLabel lab = (JLabel) Panel4LabelComboButton.getJpan().getComponent(comp        - 1);      string += " " + lab.getText();      return lab.getText().substring(lab.getText().length() - 2, lab.getText()        .length());    } else if (stat < req) {      string = "Fail " + Panel4Careers.p4lcb.getSelectedItemFromCombo(comp)        .toString()        + " > " + att + UXP.hex2Num(idx, Panel4Careers.getUPP());      string = "0";// + (req - stat);    }    return string;  }  /**   @param i       number of combo   @param dms     int array to go through   @param fail    NOT USED   @param succeed NOT USED   */  public static void workIt(int i, int[] dms, String fail, String succeed) {    target = 0;    if (!"".equals(Panel4Careers.p4lcb.getSelectedItemFromCombo(i).toString())) {      target = Integer.parseInt(Panel4Careers.p4lcb.getSelectedItemFromCombo(i));      Debug.debug("target = " + target);    } else {    }    int DM = 0;    for (int j = 0; j < dms.length; j++) {      try {        DM += Integer.parseInt(checkScores(Panel4Careers.p4lcb          .getSelectedItemFromCombo(dms[j]).toString(), dms[j]));      } catch (NumberFormatException nfe) {      }    }    int numa = rollDice(2, 6);    Debug.debug("roll(2,6) = " + numa + " + DM+" + DM + " = " + (DM + numa));    int total = numa + DM;// + Dms[0] + Dms[1];    if (total < target) {      Debug.debug("Fail");//            checkList(fail);    }    if (total >= target) {      Debug.debug("Pass");      if ((i == 19) & (commissioned == false)) {        commissioned = true;        rank = 1;      }      if ((i == 25) & (commissioned == true)) {        //rank += 1;      }//            checkList(succeed);    }  }  /**   term count   */  public static void employed() {    Panel4Careers.terms = 1;  }  /**   whether promoted   */  public static void promoted() {    Panel4Careers.ranknum += 1;    showRank();  }  /**   whether extra benefits by rank   */  public static void mustered() {    Debug.debug("Panel4Careers.terms = " + Panel4Careers.terms);    Panel4Careers.mustersgained = Panel4Careers.terms;    showRank();    switch (Panel4Careers.ranknum) {      case 1:      case 2:        Panel4Careers.mustersgained += 1;        break;      case 3:      case 4:        Panel4Careers.mustersgained += 2;        break;      case 5:      case 6:        Panel4Careers.mustersgained += 3;        break;    }    Panel4Careers.skillsgained = Panel4Careers.terms + 1;    Panel4Careers.skillsgained += Panel4Careers.ranknum;    Debug.debug("Panel4Careers.terms = " + Panel4Careers.terms);    enable(0, 50, false);    enable(36, 54, true);    Debug.debug("Panel4Careers.terms = " + Panel4Careers.terms);    Debug.debug("Panel4Careers.skillsgained = " + Panel4Careers.skillsgained);    Debug.debug("Panel4Careers.mustersgained = " + Panel4Careers.mustersgained);  }  /**   @param string skill or stat increase gained   */  public static void addSkill(String string) {    Panel4Careers.skillslist.add(string);    Panel4Careers.skillsgained -= 1;    if ((Panel4Careers.skillsgained < 1) & (Panel4Careers.mustersgained < 1)) {      enable(42, 54, false);      showGains();    }  }  /**   @param stat UPP to compare against val   @param val  stat and value to compare against stat   @param inc  whether or not stat should increase   @return 0 if nothing to do, negative if needs modifying   */  public static int compareStat2Val(String stat, String val, boolean inc) {    //String string = null;    String att = val.substring(0, 3);    String numa = val.substring(4, val.length());    int x = 0;    switch (numa) {      case "A":        x = 10;        break;      case "B":        x = 11;        break;      case "C":        x = 12;        break;      case "D":        x = 13;        break;      case "E":        x = 14;        break;      case "F":        x = 15;        break;      default:        try {          x = Integer.parseInt(numa);        } catch (NumberFormatException nfe) {          Debug.debug("NumberFormatException = " + nfe);        }        break;    }    int idx = 0;    //Debug.debug("numa = " + numa);    switch (att) {      case "STR":        idx = 0;        break;      case "DEX":        idx = 1;        break;      case "END":        idx = 2;        break;      case "INT":        idx = 3;        break;      case "EDU":        idx = 4;        break;      case "SOC":        idx = 5;        break;    }    int sta = UXP.hex2Num(idx, Panel4Careers.getUPP());    int req = x;    //val=val.substring(4, val.length());    //return (0);//ok if not negative    Debug.debug("req = " + req);    Debug.debug("sta = " + sta);    Debug.debug("sta-req = " + (sta - req));    num = (sta - req);    Debug.debug("num = " + num);    if (num < 0) {      if (inc) {        Debug.debug("num<0 = increase stat");        String old = stat;        stat = stat.substring(0, idx);        stat += UXP.num2Hex(x);        stat += old.substring(idx + 1, 6);        Debug.debug("stat now = " + UXP.addTotal(stat));        Panel4Careers.jtf2.setText(UXP.addTotal(stat));      }      if (!inc) {        Debug.debug("num<0 = but do not increase");      }    }    if (num >= 0) {      Debug.debug("num>=0 = no increase");    }    return num;  }  private static void showGains() {    Debug.debug("Panel4Careers.skillslist.size() = " + Panel4Careers.skillslist      .size());    Debug.debug("Panel4Careers.musterlist.size() = " + Panel4Careers.musterlist      .size());    musterBenefits();  }  private static void showRank() {    Panel4Careers.p4lcb.setSelectedInCombo(34, Panel4Careers.ranknum);  }  /**   @param compstart start of components   @param compend   end of components   @param enable    yes/no   */  public static void enable(int compstart, int compend, boolean enable) {    for (i = compstart; i < compend; i++) {      Panel4LabelComboButton.getJpan().getComponent(i).setEnabled(enable);    }  }  /**   @param table derived from   @param comp  component to modify   */  public static void skillGain(String table, int comp) {    roll = 0 + CareerGen.rollDice(1, 6);    Debug.debug(table + " roll = " + roll + " = " + Panel4Careers.p4lcb      .getItemFromCombo(comp, roll).toString());    Panel4Careers.p4lcb.setSelectedInCombo(comp, roll);    CareerGen.addSkill(Panel4Careers.p4lcb.getItemFromCombo(comp, roll)      .toString());  }  /**   @param i number of JComboBox   */  public static void calcModifiers(int i) {    Debug.debug("DM = " + CareerGen.checkScores(Panel4Careers.p4lcb      .getItemFromCombo(i, 0).toString(), i));    switch (Panel4Careers.p4lcb.getSelectedItemFromCombo(i).toString()) {      case "Stat Increase":        Debug.debug("Increase Stat?");        String stat = Panel4Careers.getUPP();        String val = Panel4Careers.p4lcb.getItemFromCombo(i, 0);        CareerGen.compareStat2Val(stat, val, true);    }    Panel4Careers.p4lcb.setSelectedInCombo(i, 0);  }  /**   musterBenefits   */  public static void musterBenefits() {    ArrayList<String> list = new ArrayList<>();    for (int j = 0; j < 2; j++) {      switch (j) {        case 0:          list = Panel4Careers.musterlist;          showMusterList();          break;        case 1:          list = Panel4Careers.skillslist;          break;      }      for (i = 0; i < list.size(); i++) {        string = list.get(i).toString();        if (string.contains("+") | string.contains("-")) {          mods += 1;          mod.add(string);        } else if (string.contains("KCr")) {          cashs += 1;          cash.add(string);        } else if ((!string.contains("+")) | (!string.contains("-")) | (!string          .contains("KCr"))) {          if (j == 0) {            mats += 1;            mat.add(string);          }          if (j == 1) {            skills += 1;            skill.add(string);          }        }      }    }    Debug.debug("Material benefits = " + mats);    Debug.debug("Stat modifier benefits = " + mods);    Debug.debug("Cash benefits = " + cashs);    Debug.debug("Skill benefits = " + skills);    chooseMods();    chooseCashs();    chooseMats();    chooseSkills();  }  private static void chooseMods() {    //show("Mods");    for (i = 0; i < mod.size(); i++) {      Panel4Careers.jtf2.setText(UXP.changeStats(mod.get(i), Panel4Careers.jtf2        .getText()));    }  }  private static void chooseCashs() {    //show("Cashs");    KCr = 0;    for (i = 0; i < cash.size(); i++) {      num = Integer.parseInt(cash.get(i).toString().substring(0, cash.get(i)        .toString().length() - 4));      Debug.debug(" = " + num);      KCr += num;    }    Panel4Careers.Cash = "" + KCr;  }  private static void chooseMats() {    //show("Mats");    al = mat;    //countMultiples(true);    countMats();  }  private static void chooseSkills() {    al = skill;    countMultiples(false);  }  /**   @param string to show   */  public static void show(String string) {    ArrayList<String> al = new ArrayList<>();    String gain = null;    switch (string) {      case "Mods":        al = mod;        gain = "Statistic benefit";        break;      case "Cashs":        al = cash;        gain = "Cash benefit";        break;      case "Mats":        al = mat;        gain = "Material benefit";        break;      case "Skills":        al = skill;        gain = "Skill benefit";        break;    }    for (i = 0; i < al.size(); i++) {      Debug.debug(gain + "[" + i + "] = " + al.get(i).toString());    }  }  /**   @param ra arraylist to check   @return ArrayList of values counted   */  public static ArrayList<String> countMultiples(ArrayList<String> ra) {    ArrayList<String> tmp = new ArrayList<>();    for (i = 0; i < ra.size(); i++) {      if (!ra.contains(al.get(i))) {        tmp.add(al.get(i) + "-" + countTimes(al.get(i)));        Debug.debug(tmp.get(i));      }    }    return tmp;  }  /**   @param material material or skills   @return arraylist   */  public static ArrayList<String> countMultiples(boolean material) {    Debug.debug("\n\tcountMultiples");    returns = new ArrayList<>();    if (al.size() > 0) {      j = 0;      k = 0;      ArrayList<String> ra = new ArrayList<>();      if (material == false) {        ra = names;        //show("Skills");      } else if (material == true) {        ra = mat;        //show("Mats");      }      for (i = 0; i < al.size(); i++) {        if (!ra.contains(al.get(i))) {          ra.add(al.get(i));          Debug.debug(al.get(i) + "-" + countTimes(al.get(i)));        }      }    }    return returns;  }  /**   @param string string to count number of   @return number of times in arraylist   */  public static String countTimes(String string) {    num = 0;    for (int j = 0; j < al.size(); j++) {      if (al.get(j).contains(string)) {        num += 1;      }    }    return "" + num;  }  private static void showMusterList() {    for (int i = 0; i < Panel4Careers.musterlist.size(); i++) {      Debug.debug("musterlist.get(" + i + ") = " + Panel4Careers.musterlist.get(        i));    }  }  private static void countMats() {    al = new ArrayList<>();    al = Panel4Careers.musterlist;    for (i = 0; i < al.size(); i++) {      Debug.debug("al.get(" + i + ") = " + al.get(i));      //sow.append(al.get(i));    }  }}